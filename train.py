import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from torchvision import transforms
from torchvision.datasets import ImageFolder
from model import *


transform = transforms.Compose(
    [
        transforms.Resize((64, 64)),
        transforms.RandomHorizontalFlip(p=0.3),
        transforms.RandomRotation(degrees=20),
        transforms.ToTensor(),
        transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),
    ]
)

dataset = ImageFolder("./data", transform=transform)
data_loader = DataLoader(dataset, batch_size=64, shuffle=True, num_workers=2)


checkpoint = torch.load("weights/car_weights.pth")

G = Generator()
D = Discriminator()

optimG = torch.optim.Adam(G.parameters(), lr=0.0002, betas=(0.5, 0.999))
optimD = torch.optim.Adam(D.parameters(), lr=0.0002, betas=(0.5, 0.999))

criterion = nn.BCELoss()

try:
    G.load_state_dict(checkpoint["Generator"])
    D.load_state_dict(checkpoint["Discriminator"])
    optimG.load_state_dict(checkpoint["OptimizerG"])
    optimD.load_state_dict(checkpoint["OptimizerD"])
    epoch_checkpoint = checkpoint["epoch"] + 1

except Exception:
    G.apply(weights_init)
    D.apply(weights_init)
    epoch_checkpoint = 1


epochs = 50
for epoch in range(epoch_checkpoint, epochs + 1):
    for i, batch in enumerate(data_loader, 0):
        images, _ = batch

        # Training Discriminator with Real Images
        D.zero_grad()
        output = D(images)
        target = torch.ones(images.shape[0])
        errRD = criterion(output, target)

        # Training Discriminator with Fake Images Generated by Generator
        random_noise = torch.randn((images.shape[0], 100, 1, 1))
        fakes = G(random_noise)
        output = D(fakes.detach())
        target = torch.zeros(images.shape[0])
        errFD = criterion(output, target)

        # BackPropagation
        errD = errRD + errFD
        errD.backward()
        optimD.step()

        # Training Generator
        G.zero_grad()
        output = D(fakes)
        target = torch.ones(images.shape[0])
        errG = criterion(output, target)

        # BackPropagation
        errG.backward()
        optimG.step()

        print(
            f"[EP:{epoch+1}/{epochs}][BT:{i+1}/{len(data_loader)}] LossD: {errD:.2f} LossG: {errG:.2f}"
        )

    saveCheckpoint(G, D, optimG, optimD, epoch, "weights/weights.pth")
